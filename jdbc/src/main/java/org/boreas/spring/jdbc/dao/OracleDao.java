package org.boreas.spring.jdbc.dao;

import java.beans.PropertyDescriptor;
import java.lang.reflect.Method;
import java.sql.PreparedStatement;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import javax.annotation.Resource;

import org.boreas.spring.jdbc.PageQuery;
import org.boreas.spring.jdbc.config.oracle.OracleDaoConfig;
import org.boreas.spring.jdbc.config.oracle.OracleNameMapper;
import org.boreas.spring.util.StringUtils;
import org.springframework.jdbc.core.PreparedStatementCreatorFactory;
import org.springframework.jdbc.core.StatementCreatorUtils;
import org.springframework.jdbc.support.GeneratedKeyHolder;
import org.springframework.jdbc.support.KeyHolder;
import org.springframework.util.Assert;
import org.springframework.util.CollectionUtils;
import org.springframework.util.NumberUtils;

/**
 * Implementation of {@code AbstractDao} for Oracle. Offer some common used
 * functions for convenience.
 * 
 * @author boreas
 *
 * @param <ID>
 *            type of id which is only a single column primary key.
 * @param <T>
 *            type of POJO
 */
public abstract class OracleDao<ID, T> extends AbstractJdbcDao<ID, T> {

	private List<String> columns;
	private String sequenceSql;
	private String batchSequenceSql;
	private PreparedStatementCreatorFactory insertWithGenerateIdFactory;
	private String insertWithFilledIdSql;
	/**
	 * Hold a thread-safe {@code SimpleDateFormat} object.
	 */
	private final ThreadLocal<SimpleDateFormat> sdf;

	public OracleDao() {
		sdf = new ThreadLocal<SimpleDateFormat>() {
			@Override
			protected SimpleDateFormat initialValue() {
				return new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
			}
		};
	}

	@Resource
	public final void initWithNameMapper(OracleNameMapper nameMapper) {
		Assert.notNull(nameMapper, "nameMapper cannot be null.");
		init(nameMapper);
	}

	@Override
	public void insert(T bean) {
		Assert.state(columns != null, "must initialize first.");
		String idColumn = getDaoConfig().getIdColumn();
		if (getValue(bean, idColumn) == null) {
			KeyHolder keyHolder = new GeneratedKeyHolder();
			Object[] params = initInsertParameters(bean, true);
			getJdbcTemplate()
					.update(insertWithGenerateIdFactory
							.newPreparedStatementCreator(params),
							keyHolder);
			for (String column : keyHolder.getKeys().keySet()) {
				if (idColumn.equalsIgnoreCase(column)) {
					Number id = (Number) keyHolder.getKeys().get(column);
					setAutoGeneratedId(bean, idColumn, id);
				}
			}
		} else
			getJdbcTemplate().update(insertWithFilledIdSql,
					initInsertParameters(bean, false));
	}

	@Override
	public void insert(Collection<T> beans) {
		if (CollectionUtils.isEmpty(beans))
			return;
		if (beans.size() == 1) {
			insert(beans.iterator().next());
			return;
		}

		String idColumn = getDaoConfig().getIdColumn();
		List<T> needId = new ArrayList<T>();
		for (T bean : beans) {
			if (getValue(bean, idColumn) == null)
				needId.add(bean);
		}
		Iterator<ID> ids = generateIds(needId.size()).iterator();
		for (T bean : needId) {
			setValue(bean, idColumn, ids.next());
		}

		List<Object[]> batchArgs = new ArrayList<Object[]>(beans.size());
		for (T bean : beans) {
			batchArgs.add(initInsertParameters(bean, false));
		}
		getJdbcTemplate().batchUpdate(insertWithFilledIdSql, batchArgs);
	}

	@SuppressWarnings("unchecked")
	private void setAutoGeneratedId(T bean, String idColumn, Number id) {
		Method setter = getDescriptors().get(idColumn).getWriteMethod();
		Class<?>[] paramTypes = setter.getParameterTypes();
		if (paramTypes.length > 0) {
			Class<? extends Number> idType = (Class<? extends Number>) paramTypes[0];
			setValue(bean, idColumn,
					NumberUtils.convertNumberToTargetClass(id, idType));
		}
	}

	private Object[] initInsertParameters(T bean, boolean generateId) {
		Object[] params = new Object[generateId ? columns.size() - 1 : columns
				.size()];
		String idColumn = getDaoConfig().getIdColumn();
		for (int i = 0; i < params.length; i++) {
			String column = columns.get(i);
			if (!generateId || !idColumn.equals(column)) {
				Object value = getValue(bean, column);
				if (value instanceof Date && value != null)
					params[i] = sdf.get().format(value);
				else
					params[i] = value;
			}
		}
		return params;
	}

	/**
	 * <p>
	 * Generate a bunch of IDs which are usually used in batch insert for the
	 * reason that {@link PreparedStatement#getGeneratedKeys()} cannot return
	 * more than 1 record with the restriction of socket protocol so that it's
	 * impossible to get the IDs inserted by {@code sequence_name.nextval}
	 * directly. An alternative solution is querying a bunch of IDs from
	 * sequence first, then insert them into table. But these actions are not
	 * atomic.
	 * </p>
	 * <b>Note: </b>If no more rules is in demand, just return
	 * {@link #querySequence(Class, int)}. Otherwise handle the additional
	 * transitions(eg. add a prefix/suffix) in implementation.
	 * 
	 * @param n
	 *            indicate how many IDs need to generate
	 * @return the list of generated IDs
	 */
	protected abstract List<ID> generateIds(int n);

	/**
	 * Query several values from sequence.
	 * 
	 * @param sequencename
	 * @return
	 * @see #generateIds(int)
	 */
	protected <N extends Number> List<N> querySequence(Class<N> sequenceType,
			int n) {
		Assert.isTrue(n > 0, "The value must be greater than zero");
		if (n == 1) {
			Assert.state(StringUtils.isEmpty(sequenceSql),
					"sequenceSql must be initialized.");
			return getJdbcTemplate().queryForList(sequenceSql, sequenceType);
		} else {
			Assert.state(StringUtils.isEmpty(batchSequenceSql),
					"batchSequenceSql must be initialized.");
			return getJdbcTemplate().queryForList(batchSequenceSql,
					sequenceType, n);
		}
	}

	private void init(OracleNameMapper nameMapper) {
		OracleDaoConfig<T> daoConfig = (OracleDaoConfig<T>) config();
		Class<T> beanType = daoConfig.getBeanType();
		Assert.notNull(beanType, "beanType cannot be null.");
		String tableName = nameMapper.buildTableName(beanType);
		daoConfig.setTableName(tableName);
		String sequenceName = nameMapper.buildSequenceName(beanType)
				.toUpperCase();
		daoConfig.setSequenceName(sequenceName.toUpperCase());
		buildSequenceSql(sequenceName);
		setConfig(daoConfig);
		buildInsertSql(tableName, daoConfig.getIdColumn(), sequenceName);
	}

	/**
	 * Create the SQL strings with the specified sequence name, including a
	 * single value query and a batch query. Cache the generated SQLs.
	 * 
	 * @param sequenceName
	 */
	private void buildSequenceSql(String sequenceName) {
		StringBuilder sql = new StringBuilder("select ").append(sequenceName)
				.append(".nextval from ");
		sequenceSql = new StringBuilder(sql).append("dual").toString()
				.toUpperCase();
		batchSequenceSql = new StringBuilder(sql)
				.append("(select level from dual connect by level<=?")
				.toString().toUpperCase();
	}

	/**
	 * Initialize SQLs, columns and {@code PreparedStatementCreatorFactory} with
	 * the specified table name, id column and sequence name.
	 * 
	 * @param tableName
	 * @param idColumn
	 * @param sequenceName
	 */
	private void buildInsertSql(String tableName, String idColumn,
			String sequenceName) {
		Assert.state(getDescriptors() != null, "Must initialize descriptors.");
		Map<String, PropertyDescriptor> descriptors = getDescriptors();
		StringBuilder insert = new StringBuilder("INSERT INTO ").append(
				tableName).append(" (");
		columns = new ArrayList<String>(descriptors.size());
		List<String> values = new ArrayList<String>(descriptors.size());
		int[] types = new int[descriptors.size() > 1 ? descriptors.size() - 1
				: 0];
		int i = 0;
		Integer indexOfId = null;
		for (String column : descriptors.keySet()) {
			Class<?> type = descriptors.get(column).getPropertyType();
			columns.add(column);
			String value;
			int sqlType;
			if (Date.class.isAssignableFrom(type)) {
				value = "to_date(?,'yyyy-MM-dd HH24:mi:ss')";
				sqlType = StatementCreatorUtils
						.javaTypeToSqlParameterType(String.class);
			} else {
				value = "?";
				sqlType = StatementCreatorUtils
						.javaTypeToSqlParameterType(type);
			}
			if (column.equalsIgnoreCase(idColumn))
				indexOfId = columns.size() - 1;
			else
				types[i++] = sqlType;
			values.add(value);
		}
		Assert.notNull(indexOfId, idColumn + " is not found in class "
				+ getDaoConfig().getBeanType().getName());
		insertWithFilledIdSql = new StringBuilder(insert)
				.append(StringUtils.combine(",", columns)).append(") values(")
				.append(StringUtils.combine(",", values)).append(")")
				.toString().toUpperCase();
		values.set(indexOfId, sequenceName + ".nextval");
		String insertWithGenerateIdSql = new StringBuilder(insert)
				.append(StringUtils.combine(",", columns)).append(") values(")
				.append(StringUtils.combine(",", values)).append(")")
				.toString().toUpperCase();

		insertWithGenerateIdFactory = new PreparedStatementCreatorFactory(
				insertWithGenerateIdSql, types);
		insertWithGenerateIdFactory.setReturnGeneratedKeys(true);
		insertWithGenerateIdFactory
				.setGeneratedKeysColumnNames(new String[] { idColumn });

	}

	@Override
	protected String buildPagedSQL(PageQuery pageQuery) {
		int start = (pageQuery.getPagination() - 1) * pageQuery.getPageSize();
		int end = start + pageQuery.getPageSize();
		return new StringBuilder("select * from (select t.*,rownum rn from (")
				.append(pageQuery.getRecordSql()).append(") t) where rn>")
				.append(start).append(" and rn<=").append(end).toString();
	}
}
